<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>MikroORM Blog</title>
        <link>https://mikro-orm.io/blog</link>
        <description>MikroORM Blog</description>
        <lastBuildDate>Tue, 13 Oct 2020 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[MikroORM 4.1: Let’s talk about performance]]></title>
            <link>https://mikro-orm.io/blog/mikro-orm-4-1-released</link>
            <guid>mikro-orm-4-1-released</guid>
            <pubDate>Tue, 13 Oct 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[I just shipped version 4.1 of MikroORM,]]></description>
            <content:encoded><![CDATA[<p>I just shipped version 4.1 of <a href="https://github.com/mikro-orm/mikro-orm">MikroORM</a>,
the TypeScript ORM for Node.js, and I feel like this particular release deserves
a bit more attention than a regular feature release.</p><p><img src="https://cdn-images-1.medium.com/max/725/0*R2CETMgg1344gf0V.jpg"/></p><h3>In case you don’t know…</h3><p>If you never heard of <a href="https://github.com/mikro-orm/mikro-orm">MikroORM</a>, it’s a TypeScript data-mapper ORM with Unit of Work and Identity Map. It supports MongoDB, MySQL, PostgreSQL and SQLite drivers currently. Key features of the ORM are:</p><ul><li><a href="https://github.com/mikro-orm/mikro-orm#implicit-transactions">Implicit transactions</a></li><li><a href="https://github.com/mikro-orm/mikro-orm#changeset-based-persistence">ChangeSet based persistence</a></li><li><a href="https://mikro-orm.io/docs/identity-map/">Identity map</a></li></ul><p><img src="https://cdn-images-1.medium.com/max/1024/0*zPahC74XliMguexT.png"/></p><p>You can read the full <a href="https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02">introductory article here</a> or <a href="https://mikro-orm.io/">browse through the docs</a>.</p><h3>So what changed?</h3><p>This release had only one clear goal in mind — the performance. It all started with <a href="https://github.com/mikro-orm/mikro-orm/issues/732">an issue</a> pointing out that flushing 10k entities in a single unit of work is very slow. While this kind of use case was never a target for me, I started to see all the possibilities the Unit of Work pattern offers.</p><h3>Batch inserts, updates and deletes</h3><p>The biggest performance killer was the amount of queries — even if the query is as simple and optimised as possible, firing 10k of those will be always quite slow. For inserts and deletes, it was quite trivial to group all the queries. A bit more challenging were the updates — to batch those, MikroORM now uses case statements.</p><p>As a result, when you now flush changes made to one entity type, only one query per given operation (create/update/delete) will be executed. This brings significant difference, as we are now executing fixed number of queries (in fact the changes are batched in chunks of 300 items).</p><pre><code class="language-ts">for (let i = 1; i &lt;= 5; i++) {
  const u = new User(`Peter ${i}`, `peter+${i}@foo.bar`);
  em.persist(u);
}

await em.flush();

// insert into `user` (`name`, `email`) values
//   (&#x27;Peter 1&#x27;, &#x27;peter+1@foo.bar&#x27;),
//   (&#x27;Peter 2&#x27;, &#x27;peter+2@foo.bar&#x27;),
//   (&#x27;Peter 3&#x27;, &#x27;peter+3@foo.bar&#x27;),
//   (&#x27;Peter 4&#x27;, &#x27;peter+4@foo.bar&#x27;),
//   (&#x27;Peter 5&#x27;, &#x27;peter+5@foo.bar&#x27;);
</code></pre><pre><code class="language-ts">for (const user of users) {
  user.name += &#x27; changed!&#x27;;
}

await em.flush();

// update `user` set
//   `name` = case 
//     when (`id` = 1) then &#x27;Peter 1 changed!&#x27; 
//     when (`id` = 2) then &#x27;Peter 2 changed!&#x27; 
//     when (`id` = 3) then &#x27;Peter 3 changed!&#x27; 
//     when (`id` = 4) then &#x27;Peter 4 changed!&#x27; 
//     when (`id` = 5) then &#x27;Peter 5 changed!&#x27; 
//     else `priority` end 
//   where `id` in (1, 2, 3, 4, 5)
</code></pre><pre><code class="language-ts">em.remove(users);
await em.flush();

// delete from `user` where `id` in (1, 2, 3, 4, 5)
</code></pre><h3>JIT compilation</h3><p>Second important change in 4.1 is JIT compilation. Under the hood, MikroORM now first generates simple functions for comparing and hydrating entities, that are tailored to their metadata definition. The main difference is that those generated functions are accessing the object properties directly (e.g. o.name), instead of dynamically (e.g. o<!-- -->[prop.name]<!-- -->), as all the information from metadata are inlined there. This allows V8 to better understand the code so it is able to run it faster.</p><h3>Results</h3><p>Here are the results for a simple 10k entities benchmark:</p><p><img src="https://cdn-images-1.medium.com/max/1024/1*aROevToSrzcQdPsPzXYnSQ.png"/></p><p>In average, inserting 10k entities takes around 70ms with sqlite, updates are a tiny bit slower. You can see results for other drivers here: <a href="https://github.com/mikro-orm/benchmark">https://github.com/mikro-orm/benchmark</a>.</p><p><img src="https://cdn-images-1.medium.com/max/400/0*2WaopAkejC3T6213.jpg"/></p><h3>Acknowledgement</h3><p>Kudos to <a href="https://github.com/marcj">Marc J. Schmidt</a>, the author of the initial issue, as without his help this would probably never happen, or at least not in near future. Thanks a lot!</p><blockquote><p><em>Like</em> <a href="https://mikro-orm.io/"><em>MikroORM</em></a><em>? ⭐️</em> <a href="https://github.com/mikro-orm/mikro-orm"><em>Star it</em></a> <em>on GitHub and share this article with your friends. If you want to support the project financially, you can do so via</em> <a href="https://github.com/sponsors/B4nan"><em>GitHub Sponsors</em></a><em>.</em></p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MikroORM 4: Filling the Gaps]]></title>
            <link>https://mikro-orm.io/blog/mikro-orm-4-released</link>
            <guid>mikro-orm-4-released</guid>
            <pubDate>Tue, 08 Sep 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[After 4 months of active development, I am thrilled to announce the release of MikroORM 4. When I started to work on v4, the goal was to make it relatively small release, mainly to drop support for TypeScript 3.6 and Node.js 8, and to split the project into multiple packages, so we can have more fine grained control over the dependencies (mainly because of ts-morph having TS as a runtime dependency).]]></description>
            <content:encoded><![CDATA[<p>After 4 months of active development, I am thrilled to announce the release of <a href="http://github.com/mikro-orm/mikro-orm">MikroORM 4</a>. When I started to work on v4, the goal was to make it relatively small release, mainly to drop support for TypeScript 3.6 and Node.js 8, and to split the project into multiple packages, so we can have more fine grained control over the dependencies (mainly because of ts-morph having TS as a runtime dependency).</p><blockquote><p>But what a major release would that be, without having a bunch of new features as well, right?</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/1024/0*JU7VN0bgkL57RnZJ" alt="Photo by Ryoji Iwata on Unsplash"/></p><h3>In case you don’t know…</h3><p>If you never heard of <a href="https://github.com/mikro-orm/mikro-orm">MikroORM</a>, it’s a TypeScript data-mapper ORM with Unit of Work and Identity Map. It supports MongoDB, MySQL, PostgreSQL and SQLite drivers currently. Key features of the ORM are:</p><ul><li><a href="https://github.com/mikro-orm/mikro-orm#implicit-transactions">Implicit transactions</a></li><li><a href="https://github.com/mikro-orm/mikro-orm#changeset-based-persistence">ChangeSet based persistence</a></li><li><a href="https://mikro-orm.io/docs/identity-map/">Identity map</a></li></ul><p><img src="https://cdn-images-1.medium.com/max/1024/0*VEfH0Y8e_cMVXad1.png"/></p><p>You can read the full <a href="https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02">introductory article here</a> or <a href="https://mikro-orm.io/">browse through the docs</a>.</p><h3>Quick summary of 3.x releases</h3><p>Before I dive into all the things v4, let’s recap the major features that landed in 3.x releases:</p><ul><li><a href="https://mikro-orm.io/docs/entity-schema">Defining entities via</a><a href="https://mikro-orm.io/docs/entity-schema">EntitySchema</a></li><li><a href="https://mikro-orm.io/docs/propagation">Propagation of changes to m:1/1:1 to inverse sides</a></li><li><a href="https://mikro-orm.io/docs/usage-with-mongo#transactions">Transactions in MongoDB</a></li><li><a href="https://mikro-orm.io/docs/composite-keys">Composite primary keys</a></li></ul><h3>Monorepo</h3><p>The first major change I want to talk about is the split into multiple packages. As mentioned above, the biggest motivation for this change was to get rid of TS as a runtime dependency, when it is not needed. Another nice example is knex, which is used as a base layer for SQL driver, but has no meaning for mongodb users. Lastly, it turned out Highlight.js, that was used for query highlighting, is also quite fat and slow, so I ended up writing custom highlighters that are built for CLI and are (almost) dependency free.</p><p>In v4, there are 12 packages and 2 highlighters, you install only what you use, and you have control over what is needed in production and what is just a dev dependency. This is especially useful for serverless users, where cold start speeds matter.</p><p>It felt natural to offer some shortcuts on the EntityManager and EntityRepository level, so we now have flavours of those classes in place, that offer things like em.execute(sql) or em.aggregate(). To access those driver specific methods, be sure to use the classes from driver packages:</p><pre><code class="language-ts">import { EntityManager } from &#x27;@mikro-orm/mysql&#x27;; // or any other SQL driver package

const em: EntityManager;
const qb = await em.createQueryBuilder(…); // or `em.execute()`, `em.getKnex()`, ...
</code></pre><blockquote><p>Database connectors like pg or sqlite3 are now dependencies of the driver packages (e. g. @mikro-orm/sqlite).</p></blockquote><h3>Filters</h3><p>Probably the most interesting feature of v4 are <a href="https://mikro-orm.io/docs/filters/">filters</a>, also known as association scopes. They allow you to define data visibility rules, both global and bound to entity. One common application of filters are soft deletes, or automatic tenant conditions.</p><pre><code class="language-ts">@Entity()
@Filter({ name: &#x27;expensive&#x27;, cond: { price: { $gt: 1000 } } })
@Filter({ name: &#x27;long&#x27;, cond: { &#x27;length(text)&#x27;: { $gt: 10000 } } })
@Filter({ name: &#x27;hasAuthor&#x27;, cond: { author: { $ne: null } }, default: true })
@Filter({ name: &#x27;writtenBy&#x27;, cond: args =&gt; ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: [&#x27;long&#x27;, &#x27;expensive&#x27;],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: &#x27;God&#x27; } },
});
</code></pre><p>Filters are applied to those methods of EntityManager: find(), findOne(), findAndCount(), findOneOrFail(), count(), nativeUpdate() and nativeDelete(). Filters can be parametric, the parameter can be also in form of callback (possibly async). You can also make the filter enabled by default.</p><blockquote><p>Filter can be defined at the entity level, dynamically via EM (global filters) or in the ORM configuration.</p></blockquote><h4>Global Filters</h4><p>We can also register filters dynamically via EntityManager API. We call such filters global. They are enabled by default (unless disabled via last parameter in addFilter() method), and applied to all entities. You can limit the global filter to only specified entities.</p><blockquote><p><em>Filters as well as filter params set on the EM will be copied to all its forks.</em></p></blockquote><pre><code class="language-ts">// bound to entity, enabled by default
em.addFilter(&#x27;writtenBy&#x27;, args =&gt; ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter(&#x27;tenant&#x27;, args =&gt; { ... });

// global, enabled by default, for only specified entities
em.addFilter(&#x27;tenant&#x27;, args =&gt; { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams(&#x27;tenant&#x27;, { tenantId: 123 });
em.setFilterParams(&#x27;writtenBy&#x27;, { id: 321 });
</code></pre><h3>EventSubscribers and flush events</h3><p>As opposed to regular lifecycle hooks, we can now use <a href="https://mikro-orm.io/docs/lifecycle-hooks/#eventsubscriber">EventSubscriber</a> to hook to multiple entities or if you do not want to pollute the entity prototype. All methods are optional, if you omit the getSubscribedEntities() method, it means you are subscribing to all entities.</p><pre><code class="language-ts">import { EntityName, EventArgs, EventSubscriber, Subscriber } from &#x27;@mikro-orm/core&#x27;;

@Subscriber()
export class AuthorSubscriber implements EventSubscriber&lt;Author&gt; {

  getSubscribedEntities(): EntityName&lt;Author&gt;[] {
    return [Author];
  }

  async afterCreate(args: EventArgs&lt;Author&gt;): Promise&lt;void&gt; {
    // ...
  }

  async afterUpdate(args: EventArgs&lt;Author&gt;): Promise&lt;void&gt; {
    // ... 
  }

}
</code></pre><h4>Flush events</h4><p>There is a <a href="https://mikro-orm.io/docs/lifecycle-hooks/#flush-events">special kind of events</a> executed during the commit phase (flush operation). They are executed before, during and after the flush, and they are not bound to any entity in particular.</p><ul><li>beforeFlush is executed before change sets are computed, this is the only event where it is safe to persist new entities.</li><li>onFlush is executed after the change sets are computed.</li><li>afterFlush is executed as the last step just before the flush call resolves. it will be executed even if there are no changes to be flushed.</li></ul><p>Flush event args will not contain any entity instance, as they are entity agnostic. They do contain additional reference to the UnitOfWork instance.</p><p>Following example demonstrates the hidden power of flush events — they allow to hook into the change set tracking, adjusting what will be persisted and how. Here we try to find a CREATE change set for entity FooBar, and if there is any, we automatically create a new FooBaz entity, connecting it to the FooBar one. This kind of operations was previously impossible, as in regular lifecycle hooks we can only adjust the entity that triggers the event.</p><pre><code class="language-ts">@Subscriber()
export class FooBarSubscriber implements EventSubscriber {

  async onFlush(args: FlushEventArgs): Promise&lt;void&gt; {
    const changeSets = args.uow.getChangeSets();
    const cs = changeSets.find(cs =&gt; cs.type === ChangeSetType.CREATE &amp;&amp; cs.entity instanceof FooBar);

    if (cs) {
      const baz = new FooBaz();
      baz.name = &#x27;dynamic&#x27;;
      cs.entity.baz = baz;
      args.uow.computeChangeSet(baz);
      args.uow.recomputeSingleChangeSet(cs.entity);
    }
  }

}

const bar = new FooBar();
bar.name = &#x27;bar&#x27;;
await em.persistAndFlush(bar);
</code></pre><h3>Joined loading strategy</h3><p>Loading of complex relations now support so called <a href="https://mikro-orm.io/docs/loading-strategies/">JOINED strategy</a>. Its name is quite self-explanatory — instead of the default (SELECT<!-- -->_<!-- -->IN) strategy, it uses single SQL query and maps the result to multiple entities.</p><pre><code class="language-ts">// with the default SELECT_IN strategy, following will issue 2 queries
const author = await orm.em.findOne(Author, 1, { populate: [&#x27;books&#x27;] });

// select * from author where id = 1;
// select * from book where author_id in (1);

// we can now use JOINED strategy to use a single query
const author = await orm.em.findOne(Author, 1, { populate: [&#x27;books&#x27;], strategy: LoadStrategy.JOINED });

// select a.*, b.* from author a left join book b on b.author_id = a.id where a.id = 1;
</code></pre><h3>Single Table Inheritance</h3><p><a href="https://mikro-orm.io/docs/inheritance-mapping/#single-table-inheritance">STI is an inheritance mapping strategy</a> where all classes of a hierarchy are mapped to a single database table. In order to distinguish which row represents which type in the hierarchy a so-called discriminator column is used.</p><blockquote><p>If no discriminator map is provided, it will be generated automatically.</p></blockquote><p>Following example defines 3 entities — they will all be stored in a single database table called person, with a special column named type, that will be used behind the scenes to know what class should be used to represent given row/entity.</p><pre><code class="language-ts">@Entity({
  discriminatorColumn: &#x27;type&#x27;,
  discriminatorMap: { person: &#x27;Person&#x27;, employee: &#x27;Employee&#x27;, owner: &#x27;Owner&#x27; },
})
export class Person {
  // …
}

@Entity()
export class Employee extends Person {
  // …
}

@Entity()
export class Owner extends Person {
  // …
}
</code></pre><h3>Embeddables</h3><p><a href="https://mikro-orm.io/docs/embeddables/">Embeddables</a> are classes which are not entities themselves, but are embedded in entities and can also be queried. You’ll mostly want to use them to reduce duplication or separating concerns. Value objects such as date range or address are the primary use case for this feature.</p><blockquote><p>Embeddables can only contain properties with basic @Property() mapping.</p></blockquote><p>Following example will result in a single database table, where the address fields will be inlined (with prefix) to the user table.</p><pre><code class="language-ts">@Entity()
export class User {

  @Embedded()
  address!: Address;

}

@Embeddable()
export class Address {
  
  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;

}
</code></pre><h3>Lazy scalar properties</h3><p>In MikroORM 4, we can mark any property as <a href="https://mikro-orm.io/docs/defining-entities#lazy-scalar-properties">lazy: true</a> to omit it from the select clause. This can be handy for properties that are too large and you want to have them available only some times, like a full text of an article.</p><p>When we need such value, we can use populate parameter to load it as if it was a reference.</p><blockquote><p>If the entity is already loaded and you need to populate a lazy scalar property, you might need to pass refresh: true in the FindOptions.</p></blockquote><pre><code class="language-ts">@Entity()
export class Book {

  @Property({ columnType: &#x27;text&#x27;, lazy: true })
  text: string;

}

const b1 = await em.find(Book, 1); // this will omit the `text` property
const b2 = await em.find(Book, 1, { populate: [&#x27;text&#x27;] }); // this will load the `text` property
</code></pre><h3>Computed Properties</h3><p>Another small enhancement in entity definition is the <a href="https://mikro-orm.io/docs/defining-entities/#formulas">@Formula() decorator</a>. It can be used to map some SQL snippet to your entity. The SQL fragment can be as complex as you want and even include subselects.</p><pre><code class="language-ts">@Entity()
export class Box {

  @Formula(&#x27;obj_length * obj_height * obj_width&#x27;)
  objectVolume?: number;

}
</code></pre><blockquote><p>Formulas will be added to the select clause automatically. In case you are facing problems with NonUniqueFieldNameException, you can define the formula as a callback that will receive the entity alias in the parameter.</p></blockquote><h3>Type-safe references</h3><p>Next feature I would like to mention is rather hidden, and is a bit experimental. In MikroORM 4, all EntityManager and EntityRepository methods for querying entities (e.g. find()) will now return special Loaded type, where we automatically infer what relations are populated. It dynamically adds special get() method to both Reference and Collection instances, that you can use to ensure the relation is loaded on the type level.</p><pre><code class="language-ts">@Entity()
export class Book {

  @PrimaryKey()
  id: number;

  @ManyToOne(() =&gt; Author, { wrappedReference: true })
  author: IdentifiedReference&lt;Author, &#x27;id&#x27;&gt;;

  @ManyToOne(() =&gt; Publisher, { wrappedReference: true })
  publisher: IdentifiedReference&lt;Publisher, &#x27;id&#x27;&gt;;

  @ManyToMany(() =&gt; BookTag)
  tags = new Collection&lt;BookTag&gt;(this);
    
}
</code></pre><pre><code class="language-ts">// will return `Loaded&lt;Book, &#x27;publisher&#x27; | &#x27;tags&#x27; &gt;`
const book = await orm.em.findOne(Book, 1, { populate: [&#x27;publisher&#x27;, &#x27;tags&#x27;] });

// the `Book.publisher.get()` will be available as we explicitly populated that relation
console.log(book.publisher.get().name);
console.log(book.publisher.$.name); // we can also use the `$` alias

// on the other hand, `Book.author` was not populated, so trying to access `get()` will fail to compile
console.log(book.author.get().name); // fails with `TS2339: Property &#x27;get&#x27; does not exist on type &#x27;IdentifiedReference&#x27;`

// we can also use it on collections
console.log(book.tags.get().map(t =&gt; t.name)); // `get()` will return array of items
</code></pre><h3>QueryBuilder improvements</h3><p>There have been quite a lot of small adjustments in QueryBuilder, to name a few things:</p><ul><li>support for subqueries and qb.ref()</li><li>using sql snippets with qb.raw()</li><li>pagination support via subselects (QueryFlag.PAGINATE)</li><li>update &amp; delete queries with auto-joining</li></ul><p>Here are few examples of those features in action:</p><pre><code class="language-ts">const qb = em.createQueryBuilder(Book);
qb.update({ price: qb.raw(&#x27;price + 1&#x27;) }).where({ uuid: &#x27;123&#x27; });

// update `book` set `price` = price + 1 where `uuid_pk` = ?&#x27;
</code></pre><pre><code class="language-ts">// following example assumes that there is a virtual (persist: false) property
// on `Author` entity named `booksTotal`

const qb1 = em.createQueryBuilder(Book, &#x27;b&#x27;);
qb1.count(&#x27;b.uuid&#x27;, true).where({ author: qb1.ref(&#x27;a.id&#x27;) });
const qb2 = em.createQueryBuilder(Author, &#x27;a&#x27;);
qb2.select([&#x27;*&#x27;, qb1.as(&#x27;Author.booksTotal&#x27;)]).orderBy({ booksTotal: &#x27;desc&#x27; });

// select `a`.*, (select count(distinct `b`.`uuid_pk`) as `count` from `book` as `b` where `b`.`author_id` = `a`.`id`) as `books_total` 
// from `author` as `a` 
// order by `books_total` desc
</code></pre><pre><code class="language-ts">// following example assumes that there is a virtual (persist: false) property
// on `Author` entity named `booksTotal`

const knex = em.getKnex();
const qb1 = em.createQueryBuilder(Book, &#x27;b&#x27;).count(&#x27;b.uuid&#x27;, true).where({ author: knex.ref(&#x27;a.id&#x27;) }).getKnexQuery();
const qb2 = em.createQueryBuilder(Author, &#x27;a&#x27;);
qb2.select(&#x27;*&#x27;).withSubQuery(qb1, &#x27;a.booksTotal&#x27;).where({ &#x27;a.booksTotal&#x27;: { $in: [1, 2, 3] } });

// select `a`.* 
// from `author` as `a`
// where (select count(distinct `b`.`uuid_pk`) as `count` from `book` as `b` where `b`.`author_id` = `a`.`id`) in (?, ?, ?)
</code></pre><pre><code class="language-ts">const qb = em.createQueryBuilder(Publisher);
qb.update({ name: &#x27;test 123&#x27; }).where({ $or: [{ books: { author: 123 } }, { books: { title: &#x27;book&#x27; } }] });

// update `publisher` set `name` = ? 
// where `id` in (select `e0`.`id` from (
//   select distinct `e0`.`id` from `publisher` as `e0` left join `book` as `e1` on `e0`.`id` = `e1`.`publisher_id` where (`e1`.`author_id` = ? or `e1`.`title` = ?)
// ) as `e0`)
</code></pre><h3>And many many more…</h3><ul><li>em.begin/commit/rollback() methods are back</li><li>using file globs for discovery (<!-- -->*<!-- -->*<!-- -->/<!-- -->*<!-- -->.entity.ts)</li><li>custom driver exceptions (UniqueConstraintViolationException, …)</li><li>adding items to not-initialized collections</li><li>bulk deletes and other performance improvements</li><li>inference of custom repository type (EntityRepositoryType)</li><li><a href="https://mikro-orm.io/docs/serializing#property-serializers">property serializers</a></li></ul><p>See the <a href="https://github.com/mikro-orm/mikro-orm/blob/master/CHANGELOG.md">changelog</a> for full list of new features and fixes.</p><h4>More example integrations</h4><ul><li>Koa: <a href="https://github.com/mikro-orm/koa-ts-example-app">https://github.com/mikro-orm/koa-ts-example-app</a></li><li>GraphQL: <a href="https://github.com/driescroons/mikro-orm-graphql-example">https://github.com/driescroons/mikro-orm-graphql-example</a></li><li>Serverless: <a href="https://github.com/thomaschaaf/serverless-mikro-orm-example-app">https://github.com/thomaschaaf/serverless-mikro-orm-example-app</a></li></ul><h3>Upgrading</h3><p>For smooth upgrading, read the full <a href="https://mikro-orm.io/docs/upgrading-v3-to-v4">upgrading guide</a>. Here are few notable breaking changes:</p><ul><li>Default metadata provider is ReflectMetadataProvider, to use ts-morph, you need to install it from @mikro-orm/reflection and explicitly provide it in the ORM configuration. If you want to use ReflectMetadataProvider, be sure to see the <a href="https://mikro-orm.io/docs/metadata-providers/#limitations-and-requirements">list of its limitations</a>.</li><li>TsMorphMetadataProvider now uses <!-- -->*<!-- -->.d.ts files in production mode, so be sure to enable them in your tsconfig.json.</li><li>@mikro-orm/core package is not dependent on knex, and therefore cannot provide methods like createQueryBuilder() — instead, those methods exist on SqlEntityManager. You can import it from the driver package, e.g. import { EntityManager } from &#x27;@mikro-orm/mysql;.</li><li>To use CLI, you need to install @mikro-orm/cli package.</li><li>When using folder based discovery, the options entitiesDirs and entitiesDirsTs are now removed in favour of entities and entitiesTs. You can now mix entity references with folders and file globs, negative globs are also supported.</li><li>For Nest.js users, there is a new <a href="https://github.com/mikro-orm/nestjs">@mikro-orm/nestjs</a> package, which is a fork of the <a href="https://github.com/dario1985/nestjs-mikro-orm">nestjs-mikro-orm</a> module with changes needed for<br/>MikroORM 4.</li></ul><h3>What’s next?</h3><p>Here are some features I’d like to work on in the near future:</p><ul><li>Improved schema diffing</li><li>ts-morph reflection via custom TS compiler plugin</li><li>Query caching</li><li>MS SQL Server support</li></ul><h3>WDYT?</h3><p>So thit is MikroORM 4, what do you think about it? What features or changes would you like to see next? Or what part of the documentation should be improved and how?</p><blockquote><p><em>Like</em> <a href="https://mikro-orm.io/"><em>MikroORM</em></a><em>? ⭐️</em> <a href="https://github.com/mikro-orm/mikro-orm"><em>Star it</em></a> <em>on GitHub and share this article with your friends. If you want to support the project financially, you can do so via</em> <a href="https://github.com/sponsors/B4nan"><em>GitHub Sponsors</em></a><em>.</em></p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MikroORM 3: Knex.js, CLI, Schema Updates, Entity Generator and more…]]></title>
            <link>https://mikro-orm.io/blog/mikro-orm-3-released</link>
            <guid>mikro-orm-3-released</guid>
            <pubDate>Thu, 16 Jan 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[New major version of the TypeScript ORM has been released, read about its new features and breaking changes.]]></description>
            <content:encoded><![CDATA[<p>New major version of the TypeScript ORM has been released, read about its new features and breaking changes.</p><h3>In case you don’t know…</h3><p>If you never heard of <a href="https://github.com/mikro-orm/mikro-orm">MikroORM</a>, it’s a TypeScript data-mapper ORM with Unit of Work and Identity Map. It supports MongoDB, MySQL, PostgreSQL and SQLite drivers currently. Key features of the ORM are:</p><ul><li><a href="https://github.com/mikro-orm/mikro-orm#implicit-transactions">Implicit transactions</a></li><li><a href="https://github.com/mikro-orm/mikro-orm#changeset-based-persistence">ChangeSet based persistence</a></li><li><a href="https://mikro-orm.io/docs/identity-map/">Identity map</a></li></ul><p><img src="https://cdn-images-1.medium.com/max/1024/0*0eZmw4DceSltEEQh.png"/></p><p>You can read the full <a href="https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02">introductory article here</a> or <a href="https://mikro-orm.io">browse through the docs</a>.</p><h3>Integrated Knex.js</h3><p>You probably know Knex.js already, but if you don’t, it is a “batteries included” SQL query builder for <strong>Postgres</strong> , <strong>MSSQL</strong> , <strong>MySQL</strong> , <strong>MariaDB</strong> , <strong>SQLite3</strong> , <strong>Oracle</strong> , and <strong>Amazon Redshift</strong> designed to be flexible, portable, and fun to use.</p><p><img src="https://cdn-images-1.medium.com/max/649/0*FHWIwC9WTwl2hkQ7.png"/></p><p>Knex.js is now used as both a query builder and a query runner for all SQL drivers. This allows to simplify SQL driver implementations as well as brings some new possibilities.</p><h4>Using Knex.js</h4><p>You can access configured knex instance via qb.getKnexQuery() method. Then you can execute it via the Connection.execute() and map the results via EntityManager.map().</p><pre><code class="language-typescript">const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: &#x27;test 123&#x27;, type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });
const knex = qb.getKnexQuery(); // instance of Knex&#x27; QueryBuilder
// do what ever you need with `knex`
const res = await orm.em.getConnection().execute(knex);
const entities = res.map(a =&gt; orm.em.map(Author, a));
console.log(entities); // Author[]
</code></pre><p>You can also get clear and configured knex instance from the connection via getKnex() method. As this method is not available on the base Connection class, you will need to either manually type cast the connection to AbstractSqlConnection (or the actual implementation you are using, e.g. MySqlConnection), or provide correct driver type hint to your EntityManager instance, which will be then automatically inferred in em.getConnection() method.</p><blockquote><p>Driver and connection implementations are not directly exported from mikro-orm module. You can import them from mikro-orm/dist (e.g. import { PostgreSqlDriver } from &#x27;mikro-orm/dist/drivers/PostgreSqlDriver&#x27;).</p></blockquote><pre><code class="language-typescript">const conn = orm.em.getConnection() as AbstractSqlConnection;
// you can make sure the `em` is correctly typed to `EntityManager&lt;AbstractSqlDriver&gt;`
// or one of its implementations:
// const em: EntityManager&lt;AbstractSqlDriver&gt; = orm.em;
const knex = conn.getKnex();
// do what ever you need with `knex`
const res = await knex;
</code></pre><h4>Connection Pooling</h4><p>With Knex.js used as a query runner, support for connection pooling is finally available. <a href="https://github.com/vincit/tarn.js">Tarn.js</a> is used for this internally, using connection pool with min: 2, max: 10 for the MySQL and PG libraries, and a single connection for sqlite3 by default. Use pool option to change this when initializing the ORM.</p><pre><code class="language-typescript">const orm = await MikroORM.init({
  entities: [Author, Book],
  dbName: &#x27;my-db-name&#x27;,
  pool: { min: 10, max: 20 }, // see https://github.com/vincit/tarn.js#usage for other pool options
});
</code></pre><h4>More SQL Drivers?</h4><p>One of the strongest reasons to integrate Knex.js was that it allows to simplify and unify SQL drivers and opens doors for implementing new SQL drivers. Knex.js currently supports (apart from those currently supported by MikroORM): MSSQL, Oracle and Amazon Redshift.</p><p>Thanks to AbstractSqlDriver and AbstractSqlConnection classes it should be fairly simple to implement them. I am open for PRs for those drivers, as I would like to focus on developing new ORM features mainly, instead of learning new SQL dialects I have never used. I will be happy to assist to anybody interested — feel free to reach me out either via Slack, email or GitHub issues.</p><h3>Simplified Entity Definition</h3><p>Now it is no longer needed to merge entities with IEntity interface, that was polluting entity&#x27;s interface with internal methods. New interfaces IdentifiedEntity\&lt;T<!-- -->&gt;<!-- -->, UuidEntity\&lt;T<!-- -->&gt;<!-- --> and MongoEntity\&lt;T<!-- -->&gt;<!-- --> are introduced, that should be implemented by entities. They are not adding any new properties or methods, keeping the entity&#x27;s interface clean.</p><p>IEntity interface has been renamed to AnyEntity\&lt;T, PK<!-- -->&gt;<!-- --> and it no longer has public methods like toJSON(), toObject() or init(). One can use wrap() method provided by ORM that will enhance property type when needed with those methods (e.g. await wrap(book.author).init()). To keep all methods available on the entity, you can still use interface merging with WrappedEntity\&lt;T, PK<!-- -->&gt;<!-- --> that both extends AnyEntity\&lt;T, PK<!-- -->&gt;<!-- --> and defines all those methods.</p><p>You will need to mark the entity by implementing one of <!-- -->*<!-- -->Entity interfaces:</p><ul><li>IdEntity\&lt;T<!-- -->&gt;<!-- --> for numeric/string PK on id property (id: number)</li><li>UuidEntity\&lt;T<!-- -->&gt;<!-- --> for string PK on uuid property (uuid: string)</li><li>MongoEntity\&lt;T<!-- -->&gt;<!-- --> for mongo, where id: string and <!-- -->_<!-- -->id: ObjectId are required</li><li>AnyEntity\&lt;T, PK<!-- -->&gt;<!-- --> for other possible properties (fill the PK property name to PK parameter, e.g.: AnyEntity\&lt;Book, &#x27;myPrimaryProperty&#x27;<!-- -->&gt;<!-- -->&#x27;)</li></ul><pre><code class="language-typescript">@Entity()
export class User implements IdEntity&lt;User&gt; {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @OneToOne()
  address?: Address;

  @ManyToMany()
  cars = new Collection&lt;Car&gt;(this);

  constructor(name: string) {
    this.name = name;
  }

}
</code></pre><p>To keep all public methods that were part of IEntity interface in v2, you can use <a href="https://mikro-orm.io/docs/defining-entities#using-wrappedentity-interface">WrappedEntity\&lt;T, PK<!-- -->&gt;<!-- --> via interface merging</a>.</p><h3>Nested Queries</h3><p>SQL driver now support nested where and orderBy conditions. This means that you can query by properties of a relationship and the relation will be automatically joined for you. They are available both in EntityManager and QueryBuilder APIs.</p><pre><code class="language-typescript">const book = await orm.em.findOne(Book, {
  author: {
    name: &#x27;Jon Snow&#x27;,
    address: {
      street: &#x27;Downing Street&#x27;,
    },
  },
}, [&#x27;author.address&#x27;]);

console.log(book.author.name); // &#x27;Jon Snow&#x27;
console.log(book.author.address.street); // &#x27;Downing Street&#x27;
</code></pre><h3>Strict Typing of Queries</h3><p>Previously the where parameter of EntityManager’s find methods (find(), findOne(), count()) was weakly typed. It allowed users to pass pretty much anything there.</p><p>Now the query is strictly typed, only entity properties and operators can be used and the type of property value is also checked.</p><pre><code class="language-typescript">// correct query
em.find(Author, {
  favouriteBook: {
    author: { name: &#x27;...&#x27; },
  },
  age: { $gte: 40 }, // operators are also supported
});

// 2 errors will be reported here
em.find(Author, {
  favouriteBook: {
    author: { born: &#x27;test&#x27; }, // string instead of Date
  },
  age: { $lte: &#x27;nan&#x27; }, // string instead of number
});
</code></pre><h3>Improved Schema Generator</h3><p>SchemaGenerator now supports creating, updating and dropping the schema. You can either get the SQL queries as array of strings or directly run them on the database.</p><blockquote><p>Always check the generated SQL first before running it.</p></blockquote><p>There is also new columnType property attribute you can use to specify the database specific column type explicitly.</p><h3>Migrations</h3><p><img src="https://cdn-images-1.medium.com/max/628/0*b3RWZY_ROCrJs3RE.jpeg"/></p><p>Better way to handle schema updates than using the SchemaGenerator directly is to use Migrations. MikroORM 3 has <a href="https://mikro-orm.io/docs/migrations">integrated support for migrations</a> via <a href="https://github.com/sequelize/umzug">umzug</a>. It allows you to generate migrations with current schema differences.</p><p>By default, each migration will be all executed inside a transaction, and all of them will be wrapped in one master transaction, so if one of them fails, everything will be rolled back.</p><h3>Generating Entities from Current Database</h3><p>As a counterpart to the SchemaGenerator that propagates changes in your entities to the database schema, there is now <a href="https://mikro-orm.io/docs/entity-generator">EntityGenerator</a> to help you with reverse engineering current database schema and creating entities based on it.</p><p>It supports basic entity definition including ManyToOne and OneToOne relationships. Currently ManyToMany will be generated as additional entity with two ManyToOne relations and you will need to refactor this yourself.</p><p>While it can help a lot, there is quite a lot of room for improvement. In future I would like to implement proper support for ManyToMany relations as well for enums and indexes. Another possible extension would be to allow editing existing entities (syncing them with current schema).</p><h3>CLI</h3><p>While you can use SchemaGenerator and EntityGenerator manually, much easier way is to use <a href="https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool">new CLI tool</a>. Simply create configuration file in root directory or add its path to package.json. TypeScript files are also supported via ts-node:</p><pre><code class="language-json">{
  &quot;name&quot;: &quot;your-app&quot;,
  &quot;dependencies&quot;: { ... },
  &quot;mikro-orm&quot;: {
    &quot;useTsNode&quot;: true,
    &quot;configPaths&quot;: [
      &quot;./src/mikro-orm.config.ts&quot;,
      &quot;./dist/mikro-orm.config.js&quot;
    ]
  }
}
</code></pre><p>Now you can use the CLI with help of <a href="https://github.com/npm/npx">npx</a>:</p><pre><code class="language-sh">$ npx mikro-orm
Usage: mikro-orm &lt;command&gt; [options]

Commands:
  mikro-orm cache:clear             Clear metadata cache
  mikro-orm cache:generate          Generate metadata cache for production
  mikro-orm generate-entities       Generate entities based on current database
                                    schema
  mikro-orm database:import &lt;file&gt;  Imports the SQL file to the database
  mikro-orm schema:create           Create database schema based on current
                                    metadata
  mikro-orm schema:drop             Drop database schema based on current
                                    metadata
  mikro-orm schema:update           Update database schema based on current
                                    metadata
  mikro-orm migration:create        Create new migration with current schema
                                    diff
  mikro-orm migration:up            Migrate up to the latest version
  mikro-orm migration:down          Migrate one step down
  mikro-orm migration:list          List all executed migrations
  mikro-orm migration:pending       List all pending migrations
  mikro-orm debug                   Debug CLI configuration

Options:
  -v, --version  Show version number                                   [boolean]
  -h, --help     Show help                                             [boolean]

Examples:
  mikro-orm schema:update --run  Runs schema synchronization
</code></pre><p>To verify your setup, you can use the mikro-orm debug command. Once you have it configured properly, you can also re-use it when initializing the ORM:</p><pre><code>// when no options parameter is provided, CLI config will be used
const orm = await MikroORM.init();
</code></pre><h3>Custom Mapping Types</h3><p><img src="https://cdn-images-1.medium.com/max/500/0*zAn0BtH_iz7b8Ywj.jpg"/></p><p>With <a href="https://mikro-orm.io/docs/custom-types/">Custom Types</a> we can now enhance how the database value will be represented in the ORM. You can define custom types by extending Type abstract class, it has 4 optional methods:</p><ul><li>convertToDatabaseValue(value: any, platform: Platform): any</li></ul><p>Converts a value from its JS representation to its database representation of this type. By default returns unchanged value.</p><ul><li>convertToJSValue(value: any, platform: Platform): any</li></ul><p>Converts a value from its database representation to its JS representation of this type. By default returns unchanged value.</p><ul><li>toJSON(value: any, platform: Platform): any</li></ul><p>Converts a value from its JS representation to its serialized JSON form of this type. By default converts to the database value.</p><ul><li>getColumnType(prop: EntityProperty, platform: Platform): string</li></ul><p>Gets the SQL declaration snippet for a field of this type. By default returns columnType of given property.</p><p>Here is a simplified version of DateType that is already present in the ORM:</p><pre><code class="language-typescript">import { Type, Platform, EntityProperty, ValidationError } from &#x27;mikro-orm&#x27;;

export class DateType extends Type {

  convertToDatabaseValue(value: any, platform: Platform): any {
    return value.toISOString().substr(0, 10);
  }

  convertToJSValue(value: any, platform: Platform): any {
    return new Date(value);
  }

  getColumnType(): string {
    return &#x27;date&#x27;;
  }

}
</code></pre><pre><code class="language-typescript">@Entity()
export class FooBar implements IdEntity&lt;FooBar&gt; {
  
  @PrimaryKey()
  id!: number;
  
  @Property({ type: DateType })
  born?: Date;

}
</code></pre><h3>And Many More…</h3><p>There are many more new features, see the <a href="https://github.com/mikro-orm/mikro-orm/blob/master/CHANGELOG.md">changelog</a> to read the full list. Here are few of them worth mentioning:</p><ul><li><a href="https://mikro-orm.io/docs/entity-references/">Improved support for References</a></li><li><a href="https://mikro-orm.io/docs/defining-entities/#enums">Navite Enum support</a></li><li><a href="https://mikro-orm.io/docs/entity-manager#fetching-paginated-results">em.findAndCount()</a> and <a href="https://mikro-orm.io/docs/entity-manager#handling-not-found-entities">em.findOneOrFail()</a> methods</li><li><a href="https://mikro-orm.io/docs/metadata-providers/#reflectmetadataprovider">ReflectMetadataProvider</a> as a fast alternative to ts-morph reflection</li><li>Improved logging with query highlighting</li><li><a href="https://mikro-orm.io/docs/deployment/#deploy-a-bundle-of-entities-and-dependencies-with-webpack">Support for bundling via Webpack</a></li><li>Eager loading</li><li><a href="https://mikro-orm.io/docs/read-connections">Read Connections</a></li><li>More strict entity definition validation</li></ul><h3>Notable Breaking Changes</h3><p>Here is a short list of breaking changes. You can see the full list in the docs: <a href="https://mikro-orm.io/docs/upgrading-v2-to-v3/">https://mikro-orm.io/docs/upgrading-v2-to-v3/</a>.</p><h4>Auto-flushing Disabled by Default</h4><blockquote><p><em>If you had</em> <em>autoFlush: false in your ORM configuration before, you can now remove this line, no changes are needed in your app.</em></p></blockquote><p>Default value for autoFlush is now false. That means you need to call em.flush() yourself to persist changes into database. You can still change this via ORM&#x27;s options to ease the transition but generally it is not recommended as it can cause unwanted small transactions being created around each persist.</p><pre><code class="language-typescript">orm.em.persist(new Entity()); // no auto-flushing by default
await orm.em.flush();
await orm.em.persist(new Entity(), true); // you can still use second parameter to auto-flush
</code></pre><h4>Transactions API</h4><p>Transactions now require using em.transactional() method, previous methods beginTransaction/commit/rollback are now removed.</p><pre><code class="language-typescript">await orm.em.transactional(async _em =&gt; {
  //... do some work
  const user = new User(...);
  user.name = &#x27;George&#x27;;
  _em.persistLater(user);
});
</code></pre><h3>Making it a bit more Professional…</h3><p>Not a big deal, but probably worth mentioning — MikroORM’s repository has been transferred to new <a href="https://github.com/mikro-orm">MikroORM GitHub Organization</a> and the website is now moved to <a href="https://mikro-orm.io">mikro-orm.io</a>. Old links should be properly redirected, if you find some 404, please let me know thru GitHub issues!</p><p>Website has also been redesigned — now it is built with Docusaurus (v2) and provides fulltext search by Algolia. The docs are now also <a href="https://mikro-orm.io/versions">versioned</a>.</p><p><a href="https://mikro-orm.io">Check it out!</a></p><p><img src="https://cdn-images-1.medium.com/max/1024/1*2pdwLgyPZNltJQ_2j8poSQ.png"/></p><h3>What’s next?</h3><p>Here are some features I am planning to work in the near future:</p><ul><li>Composite primary keys</li><li>Transactions in MongoDB</li><li>Complex hydration of joined result sets</li><li>Slow query log</li><li>M:N support in entity generator</li></ul><p>There are also some interesting suggestion in the Github issues, like <a href="https://github.com/mikro-orm/mikro-orm/issues/266">Dataloader integration</a>.</p><h4>WDYT?</h4><p>So that is MikroORM 3, what do you think about it? What features or changes would you like to see next? Or what part of the documentation should be improved and how?</p><blockquote><p><em>Like</em> <a href="https://mikro-orm.io"><em>MikroORM</em></a><em>? ⭐️</em> <a href="https://github.com/mikro-orm/mikro-orm"><em>Star it</em></a> <em>on GitHub and share this article with your friends.</em></p></blockquote><hr/>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Handling Transactions and Concurrency in MikroORM]]></title>
            <link>https://mikro-orm.io/blog/handling-transactions-and-concurrency-in-mikroorm</link>
            <guid>handling-transactions-and-concurrency-in-mikroorm</guid>
            <pubDate>Tue, 18 Jun 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[How to handle transactions and concurrency with ease.]]></description>
            <content:encoded><![CDATA[<p>How to handle transactions and concurrency with ease.</p><h2>Note about persisting</h2><p>There are 2 methods we should first describe to understand how persisting works in MikroORM: <code>em.persist()</code> and <code>em.flush()</code>.</p><p><code>em.persist(entity, flush?: boolean)</code> is used to mark new entities for future persisting. It will make the entity managed by given <code>EntityManager</code> and once <code>flush</code> will be called, it will be written to the database. Second boolean parameter can be used to invoke <code>flush</code> immediately. Its default value is configurable via <code>autoFlush</code> option.</p><blockquote><p>Default value of <code>autoFlush</code> is currently set to <code>true</code>, which will change in upcoming major release. Users are encouraged to either set <code>autoFlush</code> to <code>false</code> or use <code>em.persistLater()</code> (equal to <code>em.persist(entity, false)</code>) and <code>em.persistAndFlush()</code> methods instead. Every time persisting is mentioned in this article, it is with <code>autoFlush</code> set to <code>false</code> in mind.</p></blockquote><p>To understand <code>flush</code>, lets first define what managed entity is: An entity is managed if it’s fetched from the database (via <code>em.find()</code>, <code>em.findOne()</code> or via other managed entity) or registered as new through <code>em.persist()</code>.</p><p><code>em.flush()</code> will go through all managed entities, compute appropriate change sets and perform according database queries. As an entity loaded from database becomes managed automatically, you do not have to call <code>persist</code> on those, and <code>flush</code> is enough to update them.</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*Eo5JP9abOfPV24Uf.jpg"/></p><h2>Transaction demarcation</h2><p>Transaction demarcation is the task of defining your transaction boundaries. For the most part, MikroORM already takes care of proper transaction demarcation for you: All the write operations (INSERT/UPDATE/DELETE) are queued until <code>em.flush()</code> is invoked which wraps all of these changes in a single transaction. However, MikroORM also allows (and encourages) you to take over and control transaction demarcation yourself.</p><h3>Approach 1: Implicitly</h3><p>The first approach is to use the implicit transaction handling provided by the MikroORM <code>EntityManager</code>. Given the following code snippet, without any explicit transaction demarcation:</p><pre><code class="language-typescript">const user = new User();
user.name = &#x27;George&#x27;;
await orm.em.persistAndFlush(user);
</code></pre><p>Since we do not do any custom transaction demarcation in the above code, <code>em.flush()</code> will begin and commit/rollback a transaction. This is sufficient if all the data manipulation that is part of a unit of work happens through the domain model and thus the ORM — in other words, unless you run some write queries manually, via <code>QueryBuilder</code>, or use one of <code>em.nativeInsert/Update/Delete</code> helpers.</p><p>Here is a bit more complex example where multiple entities are involved:</p><pre><code class="language-typescript">const author = await orm.em.findOne(Author, id, [&#x27;books.tags&#x27;, &#x27;books.publisher&#x27;]);
author.books[0].title = &#x27;New book name&#x27;;
author.books[0].tags[0].name = &#x27;old&#x27;;
author.books[0].tags.add(new BookTag(&#x27;sale&#x27;));
author.books[0].publisher.name = &#x27;New publisher name&#x27;;
await orm.em.flush();
</code></pre><p>We load one author by id, all his books and their tags as well as their publisher. For simplicity, let’s assume the author has one book associated, which has one book tag and one publisher.</p><p>Then we update multiple things on book of that author, editing name of the tag, adding new one, and changing publisher’s name. As we are working with already managed entities (retrieved from <code>EntityManager</code>), we can simply <code>flush</code> without needing to <code>persist</code> those entities.</p><p>The <code>flush</code> call here will compute all differences and run database queries accordingly. They will all be encapsulated in a transaction, as you can see from following list of fired queries:</p><pre><code class="language-sql">START TRANSACTION;
INSERT INTO `book_tag` (`name`) VALUES (?);
UPDATE `book` SET `title` = ? WHERE `id` = ?;
DELETE FROM `book_to_book_tag` WHERE `book_id` = ?;
INSERT INTO `book_to_book_tag` (`book_id`, `book_tag_id`) VALUES (?, ?);
INSERT INTO `book_to_book_tag` (`book_id`, `book_tag_id`) VALUES (?, ?);
UPDATE `publisher` SET `name` = ? WHERE `id` = ?;
UPDATE `book_tag` SET `name` = ? WHERE `id` = ?;
COMMIT;
</code></pre><h3>Approach 2: Explicitly</h3><p>The explicit alternative is to use the transactions API directly to control the boundaries. The code then looks like this:</p><pre><code class="language-typescript">await orm.em.beginTransaction();

try {
  //... do some work
  const user = new User(...);
  user.name = &#x27;George&#x27;;
  await orm.em.persistAndFlush(user);
  await orm.em.commit();
} catch (e) {
  await orm.em.rollback();
  throw e;
}
</code></pre><p>Explicit transaction demarcation is required when you want to include custom DBAL operations in a unit of work (e.g. when firing native SQL UPDATE queries) or when you want to make use of some methods of the <code>EntityManager</code> API that require an active transaction (e.g. locking) — such methods will throw a <code>ValidationError</code> to inform you of that requirement.</p><p>A more convenient alternative for explicit transaction demarcation is to use <code>em.transactional(cb)</code>. It will automatically start the transaction, execute your asynchronous callback and commit it. In case of an exception during those operations, the transaction will be automatically rolled back and the exception will be re-thrown. An example that is functionally equivalent to the previously shown code looks as follows:</p><pre><code class="language-typescript">await orm.em.transactional(async _em =&gt; {
  //... do some work
  const user = new User(...);
  user.name = &#x27;George&#x27;;
  _em.persistLater(user);
});
</code></pre><p>In the callback parameter, you will get forked <code>EntityManager</code> that will contain a copy of the current Identity Map. You should use this copy instead of the parent one for all queries inside the transaction. It will be flushed prior to transaction commit.</p><h3>Exception Handling</h3><p>When using <em>implicit</em> transaction demarcation and an exception occurs during <code>em.flush()</code>, the transaction is automatically rolled back.</p><p>When using <em>explicit</em> transaction demarcation and an exception occurs, the transaction should be rolled back immediately as demonstrated in the example above. Users are encouraged to use <code>em.transactional(cb)</code> which will handle that automatically.</p><p>As a result of this procedure, all previously managed or removed instances of the <code>EntityManager</code> become detached. The state of the detached objects will be the state at the point at which the transaction was rolled back. The state of the objects is in no way rolled back and thus the objects are now out of sync with the database. The application can continue to use the detached objects, knowing that their state is potentially no longer accurate.</p><p>If you intend to start another unit of work after an exception has occurred you should do that with a new <code>EntityManager</code>. Simply use <code>em.fork()</code> to obtain fresh copy with cleared identity map.</p><p><img src="https://cdn-images-1.medium.com/max/1600/0*D4B7hf_Up9bc9wzg.jpg"/></p><h2>Concurrency and locking</h2><h3>Why we need concurrency control?</h3><p>If transactions are executed <em>serially</em> (one at a time), no transaction concurrency exists. However, if concurrent transactions with interleaving operations are allowed, you may easily run into one of those problems:</p><ol><li>The lost update problem</li><li>The dirty read problem</li><li>The incorrect summary problem</li></ol><p>Take a look at <a href="https://www.includehelp.com/dbms/concurrency-and-problem-due-to-concurrency.aspx">this article</a> for in-depth explanation of those.</p><p>To mitigate those problems, MikroORM offers support for Pessimistic and Optimistic locking strategies natively. This allows you to take very fine-grained control over what kind of locking is required for your entities in your application.</p><h3>Optimistic Locking</h3><p>Database transactions are fine for concurrency control during a single request. However, a database transaction should not span across requests, the so-called “user think time”. Therefore a long-running “business transaction” that spans multiple requests needs to involve several database transactions. Thus, database transactions alone can no longer control concurrency during such a long-running business transaction. Concurrency control becomes the partial responsibility of the application itself.</p><p>MikroORM has integrated support for automatic optimistic locking via a version field. In this approach any entity that should be protected against concurrent modifications during long-running business transactions gets a version field that is either a simple number or a Date (timestamp). When changes to such an entity are persisted at the end of a long-running conversation the version of the entity is compared to the version in the database and if they don’t match, a <code>ValidationError</code> is thrown, indicating that the entity has been modified by someone else already.</p><p>To define a version field, simply use <code>@Property</code> decorator with <code>version</code> flag set to <code>true</code>. Only <code>Date</code> and <code>number</code> types are allowed.</p><pre><code class="language-typescript">export class User {
  // ...
  @Property({ version: true })
  version: number;
  // ...
}
</code></pre><pre><code class="language-typescript">export class Book {
  // ...
  @Property({ version: true })
  version: Date;
  // ...
}
</code></pre><blockquote><p>Version numbers (not timestamps) should be preferred as they can not potentially conflict in a highly concurrent environment, unlike timestamps where this is a possibility, depending on the resolution of the timestamp on the particular database platform.</p></blockquote><p>When a version conflict is encountered during <code>em.flush()</code>, a <code>ValidationError</code> is thrown and the active transaction rolled back (or marked for rollback). This exception can be caught and handled. Potential responses to a <code>ValidationError</code> are to present the conflict to the user or to refresh or reload objects in a new transaction and then retrying the transaction.</p><p>The time between showing an update form and actually modifying the entity can in the worst scenario be as long as your applications session timeout. If changes happen to the entity in that time frame you want to know directly when retrieving the entity that you will hit an optimistic locking exception.</p><p>You can always verify the version of an entity during a request either when calling <code>em.findOne()</code>:</p><pre><code class="language-typescript">const theEntityId = 1;
const expectedVersion = 184;

try {
  const entity = await orm.em.findOne(User, theEntityId, { lockMode: LockMode.OPTIMISTIC, lockVersion: expectedVersion });
  // do the work
  await orm.em.flush();
} catch (e) {
  console.log(&#x27;Sorry, but someone else has already changed this entity. Please apply the changes again!&#x27;);
}
</code></pre><p>Or you can use <code>em.lock()</code> to find out:</p><pre><code class="language-typescript">const theEntityId = 1;
const expectedVersion = 184;
const entity = await orm.em.findOne(User, theEntityId);

try {
  // assert version
  await orm.em.lock(entity, LockMode.OPTIMISTIC, expectedVersion);
} catch (e) {
  console.log(&#x27;Sorry, but someone else has already changed this entity. Please apply the changes again!&#x27;);
}
</code></pre><p>Using optimistic locking correctly, you <strong>have</strong> to pass the version as an additional parameter when updating entity. See following example:</p><pre><code class="language-typescript">const res = await fetch(&#x27;api.example.com/book/123&#x27;);
const book = res.json();
console.log(book.version); // prints the current version

// user does some changes and calls the PUT handler
const changes = { title: &#x27;new title&#x27; };
await fetch(&#x27;api.example.com/book/123&#x27;, {
  method: &#x27;PUT&#x27;,
  body: {
    ...changes,
    version: book.version,
  },
});
</code></pre><pre><code class="language-typescript">// GET /book/:id
async findOne(req, res) {
  const book = await this.em.findOne(Book, +req.query.id);
  res.json(book);
}

// PUT /book/:id
async update(req, res) {
  const book = await this.em.findOne(Book, +req.query.id, { lockMode: LockMode.OPTIMISTIC, lockVersion: req.body.version });
  book.assign(req.body);
  await this.em.flush();

  res.json(book);
}
</code></pre><p>Your frontend app loads an entity from API, the response includes the version property. User makes some changes and fires PUT request back to the API, with version field included in the payload. The PUT handler of the API then reads the version and passes it to the <code>em.findOne()</code> call.</p><h2>Pessimistic Locking</h2><p>MikroORM supports Pessimistic Locking at the database level. Every Entity can be part of a pessimistic lock, there is no special metadata required to use this feature. Pessimistic Locking requires active transaction, so you will have to use explicit transaction demarcation.</p><p>MikroORM currently supports two pessimistic lock modes:</p><ul><li>Pessimistic Write (<code>LockMode.PESSIMISTIC_WRITE</code>), locks the underlying database rows for concurrent Read and Write Operations.</li><li>Pessimistic Read (<code>LockMode.PESSIMISTIC_READ</code>), locks other concurrent requests that attempt to update or lock rows in write mode.</li></ul><p>You can use pessimistic locks in three different scenarios:</p><ol><li>Using <code>em.findOne(className, id, { lockMode  })</code></li><li>Using <code>em.lock(entity, lockMode)</code></li><li>Using <code>QueryBuilder.setLockMode(lockMode)</code></li></ol><p>This is how it looks like in action:</p><pre><code class="language-typescript">await em.transactional(async _em =&gt; {
  await _em.findOne(Author, id, { lockMode: LockMode.PESSIMISTIC_WRITE });
});

// START TRANSACTION
// SELECT `e0`.* FROM `author` AS `e0` WHERE `e0`.`id` = ? FOR UPDATE
// COMMIT
</code></pre><pre><code class="language-typescript">const author = orm.em.findOne(Author, id);
// ...
await orm.em.transactional(async em =&gt; {
  await em.lock(author, LockMode.PESSIMISTIC_READ);
});

// SELECT `e0`.* FROM `author` AS `e0` WHERE `e0`.`id` = ?
// START TRANSACTION
// SELECT 1 FROM `author` AS `e0` WHERE `e0`.`id` = ? LOCK IN SHARE MODE
// COMMIT
</code></pre><blockquote><p>Like <a href="https://b4nan.github.io/mikro-orm/">MikroORM</a>? ⭐️ <a href="https://github.com/mikro-orm/mikro-orm">Star it</a> on GitHub and share this article with your friends.</p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Introducing MikroORM, TypeScript data-mapper ORM with Identity Map]]></title>
            <link>https://mikro-orm.io/blog/introducing-mikroorm-typescript-data-mapper-orm-with-identity-map</link>
            <guid>introducing-mikroorm-typescript-data-mapper-orm-with-identity-map</guid>
            <pubDate>Mon, 08 Apr 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[This might be the ORM you’ve been looking for…]]></description>
            <content:encoded><![CDATA[<p>This might be the ORM you’ve been looking for…</p><h2>Motivation</h2><p>During my early days at university, I remember how quickly I fell in love with object oriented programming and the concepts of <a href="http://hibernate.org/orm/what-is-an-orm/">Object-relational mapping</a> and <a href="https://stackoverflow.com/questions/1222392/can-someone-explain-domain-driven-design-ddd-in-plain-english-please/1222488#1222488">Domain Driven Design</a>. Back then, I was mainly a PHP programmer (<em>while we did a lot of Java/Hibernate at school</em>), so a natural choice for me was to start using <a href="https://www.doctrine-project.org/">Doctrine</a>.</p><p>A few years ago, when I switched from PHP to Node.js (<em>and later to TypeScript</em>), I was really confused. How come there is nothing similar to Hibernate or Doctrine in the JavaScript world? About a year ago, I finally came across <a href="https://typeorm.io/">TypeORM</a>, and when I read this line in the readme I thought I found what I was looking for:</p><blockquote><p>TypeORM is highly influenced by other ORMs, such as <a href="http://hibernate.org/orm/">Hibernate</a>, <a href="http://www.doctrine-project.org/">Doctrine</a> and <a href="https://www.asp.net/entity-framework">Entity Framework</a>.</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*gWvTBke0c8BFLGR8u_5zSg.jpeg"/></p><p>I started playing with it immediately, but I got disappointed very quickly. No Identity Map that would keep track of all loaded entities. No Unit of Work that would handle transaction isolation. No unified API for references with very strange support for <a href="https://typeorm.io/#/relations-faq/how-to-use-relation-id-without-joining-relation">accessing just the identifier without populating the entity</a>, MongoDB driver (<em>which I was aiming to use</em>) was experimental and I had a lot problems setting it up. After a few days of struggle, I went away from it.</p><p>By that time, I started to think about writing something myself. And that is how <a href="https://github.com/mikro-orm/mikro-orm"><strong>MikroORM</strong></a> started!</p><p><img src="https://cdn-images-1.medium.com/max/800/1*f8phoYPnVRkwuV1wynXz_A.png"/></p><blockquote><p><a href="https://github.com/mikro-orm/mikro-orm">MikroORM</a> is TypeScript ORM for Node.js based on Data Mapper, Unit of Work and Identity Map patterns.</p></blockquote><p>Currently it supports <strong>MongoDB</strong>, <strong>MySQL, PostgreSQL</strong> and <strong>SQLite</strong> databases, but more can be supported via <a href="https://b4nan.github.io/mikro-orm/custom-driver/">custom drivers right now</a>. It has first class TypeScript support, while staying back compatible with <a href="https://b4nan.github.io/mikro-orm/usage-with-js/">Vanilla JavaScript</a>.</p><h2>Installation</h2><p>First install the module via <code>yarn</code> or <code>npm</code> and do not forget to install the database driver as well. Next you will need to enable support for <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">decorators</a><br/>
<!-- -->in <code>tsconfig.json</code> via <code>experimentalDecorators</code> flag. Then call <code>MikroORM.init</code> as part of bootstrapping your application.</p><p>Last step is to provide forked <code>EntityManager</code> for each request, so it will have its own unique <a href="https://b4nan.github.io/mikro-orm/identity-map/">Identity Map</a>. To do so, you can use <code>EntityManager.fork()</code> method. Another way, that is more <a href="https://medium.freecodecamp.org/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f">DI</a> friendly, is to create new <a href="https://b4nan.github.io/mikro-orm/identity-map/#request-context">request context</a> for each request, which will use some <a href="https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md">dark magic</a> in the background to always pick the right <code>EntityManager</code> for you.</p><pre><code class="language-sh"># using yarn
$ yarn add mikro-orm mongodb # for mongo
$ yarn add mikro-orm mysql2  # for mysql
$ yarn add mikro-orm pg      # for postgresql
$ yarn add mikro-orm sqlite  # for sqlite

# or npm
$ npm i -s mikro-orm mongodb # for mongo
$ npm i -s mikro-orm mysql2  # for mysql
$ npm i -s mikro-orm pg      # for postgresql
$ npm i -s mikro-orm sqlite  # for sqlite
</code></pre><pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;target&quot;: &quot;es2017&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;declaration&quot;: true,
    &quot;strict&quot;: true,
    &quot;strictPropertyInitialization&quot;: false,
    &quot;experimentalDecorators&quot;: true
  }
}
</code></pre><pre><code class="language-typescript">const orm = await MikroORM.init({
  entities: [Author, Book, BookTag],
  dbName: &#x27;my-db-name&#x27;,
  clientUrl: &#x27;...&#x27;, // defaults to &#x27;mongodb://127.0.0.1:27017&#x27; for mongodb driver
  type: &#x27;mongo&#x27;, // one of &#x27;mysql&#x27;, &#x27;postgresql&#x27;, &#x27;sqlite&#x27;, defaults to &#x27;mongo&#x27;
  autoFlush: false, // read more here: https://b4nan.github.io/mikro-orm/unit-of-work/
});

console.log(orm.em); // access EntityManager via `em` property
</code></pre><pre><code class="language-typescript">const app = express();

app.use((req, res, next) =&gt; {
  req.em = orm.em.fork(); // save the fork to `req` object
});

app.get(&#x27;/books&#x27;, async (req, res) =&gt; {
  const books = await req.em.find(Book); // use the fork via `req.em`
});
</code></pre><pre><code class="language-typescript">const app = express();

// by providing request context, creating forked EntityManager will be handled automatically
app.use((req, res, next) =&gt; {
  RequestContext.create(orm.em, next);
});
</code></pre><h2>Defining entities</h2><p>To <a href="https://b4nan.github.io/mikro-orm/defining-entities/">define an entity</a>, simply create a class and decorate it. Here is an example of <code>Book</code> entity defined for MongoDB driver:</p><pre><code class="language-typescript">
import { ObjectID } from &#x27;mongodb&#x27;;
import { Collection, Entity, IEntity, ManyToMany, ManyToOne, PrimaryKey, Property } from &#x27;mikro-orm&#x27;;
import { Author, BookTag, Publisher } from &#x27;.&#x27;;

@Entity()
export class Book {

  @PrimaryKey()
  _id: ObjectID;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () =&gt; new Date() })
  updatedAt = new Date();

  @Property()
  title: string;

  @ManyToOne()
  author: Author;

  @ManyToOne()
  publisher: Publisher;

  @ManyToMany({ entity: () =&gt; BookTag, inversedBy: &#x27;books&#x27; })
  tags = new Collection&lt;BookTag&gt;(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

export interface Book extends IEntity&lt;string&gt; { }
</code></pre><p>As you can see, it’s pretty simple and straightforward. Entities are simple JavaScript objects (<em>so called POJO</em>), decorated with <code>@Entity</code> decorator (<em>for TypeScript</em>), or accompanied with <a href="https://b4nan.github.io/mikro-orm/usage-with-js/">schema definition object</a> (<em>for vanilla JavaScript</em>). No real restrictions are made, you do not have to extend any base class, you are more than welcome to <a href="https://b4nan.github.io/mikro-orm/entity-constructors/">use entity constructors</a> for specifying required parameters to always keep the entity in valid state. The only requirement is to define the primary key property.</p><p><img src="https://cdn-images-1.medium.com/max/800/1*NlsF497deWAYi5FSijW9NQ.jpeg"/></p><p>You might be curious about the last line with <code>Book</code> as an interface. This is called <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces">interface merging</a> and it is there to let TypeScript know the entity will have some extra API methods (like <code>init()</code> or <code>isInitialized()</code>) available as it will be monkey-patched during discovery process. More about this can be found <a href="https://b4nan.github.io/mikro-orm/defining-entities/">in the docs</a>.</p><h2>Persisting entities with EntityManager</h2><p>To save entity state to database, you need to <a href="https://b4nan.github.io/mikro-orm/entity-manager/">persist it</a>. Persist determines whether to use <code>insert</code> or <code>update</code> and computes appropriate change-set. As a result, only changed fields will be updated in database.</p><p><a href="https://b4nan.github.io/mikro-orm/">MikroORM</a> comes with support for <a href="https://b4nan.github.io/mikro-orm/cascading/">cascading persist and remove operations</a>. Cascade persist is enabled by default, which means that by persisting an entity, all referenced entities will be automatically persisted too.</p><pre><code class="language-typescript">const author = new Author(&#x27;Jon Snow&#x27;, &#x27;snow@wall.st&#x27;);
author.born = new Date();

const publisher = new Publisher(&#x27;7K publisher&#x27;);

const book1 = new Book(&#x27;My Life on The Wall, part 1&#x27;, author);
book1.publisher = publisher;
const book2 = new Book(&#x27;My Life on The Wall, part 2&#x27;, author);
book2.publisher = publisher;
const book3 = new Book(&#x27;My Life on The Wall, part 3&#x27;, author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await orm.em.persistAndFlush([book1, book2, book3]);

// or one by one
orm.em.persistLater(book1);
orm.em.persistLater(book2);
orm.em.persistLater(book3);
await orm.em.flush(); // flush everything to database at once
</code></pre><p><img src="https://cdn-images-1.medium.com/max/800/1*x6Oqsg8I4y4Z3FiWtn1ORA.gif"/></p><h2>Fetching entities</h2><p>To fetch entities from database you can use <code>find()</code> and <code>findOne()</code> methods of <code>EntityManager</code>:</p><pre><code class="language-typescript">// find all authors with name matching &#x27;Jon&#x27;, and populate all of their books
const authors = await orm.em.find(Author, { name: /Jon/ }, [&#x27;books&#x27;]); 

for (const author of authors) {
  console.log(author.name); // Jon Snow

  for (const book of author.books) {
    console.log(book.title); // initialized
    console.log(book.author.isInitialized()); // true
    console.log(book.author.id);
    console.log(book.author.name); // Jon Snow
    console.log(book.publisher); // just reference
    console.log(book.publisher.isInitialized()); // false
    console.log(book.publisher.id);
    console.log(book.publisher.name); // undefined
  }
}
</code></pre><p>More convenient way of fetching entities from database is by using <code>EntityRepository</code>, that carries the entity name so you do not have to pass it to every <code>find</code> and <code>findOne</code> calls:</p><pre><code class="language-typescript">import { QueryOrder } from &#x27;mikro-orm&#x27;;

const booksRepository = orm.em.getRepository(Book);

// with sorting, limit and offset parameters, populating author references
const books = await booksRepository.find({ author: &#x27;...&#x27; }, [&#x27;author&#x27;], { title: QueryOrder.DESC }, 2, 1);

// or with options object
const books = await booksRepository.find({ author: &#x27;...&#x27; }, { 
  populate: [&#x27;author&#x27;],
  limit: 1,
  offset: 2,
  sort: { title: QueryOrder.DESC },
});

console.log(books); // Book[]
</code></pre><h2>Working with references</h2><p>Entity associations are mapped to entity references. Reference is an entity that has at least the identifier (<em>primary key</em>). This reference is stored in the Identity Map so you will get the same object reference when fetching the same document from database.</p><p>Thanks to this concept, MikroORM offers unified API for accessing entity references, regardless of whether the entity is initialized or not. Even if you do not populate an association, there will be its reference with primary key set. You can call <code>await entity.init()</code> to initialize the entity. This will trigger database call and populate itself, keeping the same reference to entity object in identity map.</p><pre><code class="language-typescript">const book = orm.em.findOne(Book, &#x27;...&#x27;);
console.log(book.author); // reference with ID only, instance of Author entity

// this will get the same reference as we already have in `book.author`
const author = orm.em.getReference(Author, book.author.id);
console.log(author.id); // accessing the id will not trigger any db call
console.log(author.isInitialized()); // false
console.log(author.name); // undefined
console.log(author === book.author); // true

// this will trigger db call, we could also use `orm.em.findOne(Author, author.id)` to do the same
await author.init(); 
console.log(author.isInitialized()); // true
console.log(author.name); // defined
</code></pre><p><img src="https://cdn-images-1.medium.com/max/800/1*PY1hb2ufRhbevdIFt9jR1g.jpeg"/></p><h2>Identity Map and Unit of Work</h2><p><a href="https://b4nan.github.io/mikro-orm/">MikroORM</a> uses the Identity Map in background to track objects. This means that whenever you fetch entity via <code>EntityManager</code>, MikroORM will keep a reference to it inside its <code>UnitOfWork</code>, and will always return the same instance of it, even if you query one entity via different properties. This also means you can compare entities via strict equality operators (<code>===</code> and <code>!==</code>):</p><pre><code class="language-typescript">const authorRepository = orm.em.getRepository(Author);
const jon = await authorRepository.findOne({ name: &#x27;Jon Snow&#x27; }, [&#x27;books&#x27;]);
const jon2 = await authorRepository.findOne({ email: &#x27;snow@wall.st&#x27; });
const authors = await authorRepository.findAll([&#x27;books&#x27;]);

// identity map in action
console.log(jon === authors[0]); // true
console.log(jon === jon2); // true

// as we always have one instance, books will be populated also here
console.log(jon2.books);
</code></pre><p>Another benefit of Identity Map is that this allows us to skip some database calls. When you try to load an already managed entity by its identifier, the one from Identity Map will be returned, without querying the database.</p><p>The power of Unit of Work is in running all queries inside a batch and wrapped inside a transaction (<em>if supported by given driver</em>). This approach is usually more performant as opposed to firing queries from various places.</p><h2>Collections</h2><p><code>OneToMany</code> and <code>ManyToMany</code> collections are stored in a <code>Collection</code> wrapper. It implements iterator so you can use <code>for of</code> loop to iterate through it.</p><p>Another way to access collection items is to use bracket syntax like when you access array items. Keep in mind that this approach will not check if the collection is initialized, while using <code>get</code> method will throw error in this case.</p><pre><code class="language-typescript">// find author and populate his books collection
const author = orm.em.findOne(Author, &#x27;...&#x27;, [&#x27;books&#x27;]);

for (const book of author.books) {
  console.log(book); // instance of Book
}

author.books.add(book);
console.log(author.books.contains(book)); // true
author.books.remove(book);
console.log(author.books.contains(book)); // false
author.books.add(book);
console.log(author.books.count()); // 1
console.log(author.books.getItems()); // Book[]
console.log(author.books.getIdentifiers()); // array of primary keys of all items
author.books.removeAll();
</code></pre><p>More informations about collections can be found <a href="https://b4nan.github.io/mikro-orm/collections/">in the docs</a>.</p><h2>What’s next?</h2><p>So you read through the whole article, got here and still not satisfied? There are more articles to come (beginning with integration manual for popular frameworks like <a href="https://expressjs.com/">Express</a> or <a href="https://nestjs.com/">NestJS</a>), but you can take a look at some advanced features covered in docs right now:</p><ul><li><a href="https://b4nan.github.io/mikro-orm/nested-populate/">Smart nested populate</a></li><li><a href="https://b4nan.github.io/mikro-orm/query-conditions/">Smart query conditions</a></li><li><a href="https://b4nan.github.io/mikro-orm/entity-helper/">Updating entity values with <code>IEntity.assign()</code></a> </li><li><a href="https://b4nan.github.io/mikro-orm/property-validation/">Property validation</a></li><li><a href="https://b4nan.github.io/mikro-orm/lifecycle-hooks/">Lifecycle hooks</a></li><li><a href="https://b4nan.github.io/mikro-orm/naming-strategy/">Naming strategy</a></li><li><a href="https://b4nan.github.io/mikro-orm/usage-with-nestjs/">Usage with NestJS</a></li><li><a href="https://b4nan.github.io/mikro-orm/usage-with-js/">Usage with JavaScript</a></li></ul><p><img src="https://cdn-images-1.medium.com/max/800/1*4877k4Hq9dPdtmvg9hnGFA.jpeg"/></p><p>To start playing with <a href="https://github.com/mikro-orm/mikro-orm">MikroORM</a>, go through <a href="https://github.com/mikro-orm/mikro-orm#quick-start">quick start</a> and <a href="https://b4nan.github.io/mikro-orm/">read the docs</a>. You can also take a look at <a href="http://github.com/mikro-orm/mikro-orm-examples">example integrations with some popular frameworks</a>.</p><blockquote><p><em>Like</em> <a href="https://b4nan.github.io/mikro-orm/"><em>MikroORM</em></a><em>? ⭐️</em> <a href="https://github.com/mikro-orm/mikro-orm"><em>Star it</em></a> <em>on GitHub and share this article with your friends.</em></p></blockquote><p><em>This article was originally published on Medium: <a href="https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02">https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02</a></em></p>]]></content:encoded>
        </item>
    </channel>
</rss>